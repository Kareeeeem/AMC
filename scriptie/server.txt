De server applicatie is de tussenlaag tussen de frontend client en de inforamatie in de database. Bijvoorbeeld wanneer er via het internet iemand een oefening opvraagt bij www.dezeapplicatie.com/oefeningen/oefening3, behandeld de server applicatie deze aanvraag, kijkt of deze oefening bestaat en maakt van de representatie van de oefening in de database een representatie die geschikt is voor consumtie door een javascript applicatie. Deze nieuwe representatie wordt dan teruggestuurd naar de client die het heeft opgevraagd. In het echt zitten hier stappen tussen zoals een authenticeren van een verzoek, en verwerken en valideren van inkomende informatie, het verwerken en terugsturen van foutmeldingen. Deze server applicatie is geschreven in Python en en dit hoofdstuk wordt beschreven hoe deze laag is opgebouwd en ontwikkeld.

Om in de Python applicatie te spreken met de database wordt er de SQLAlchemy library gebruikt. Deze library abstraheerd, of vertaald de communicatie tussen relationele databases en Python zodat er in Python SQL kan worden gesproken. Ter illustratie, om in SQL een alle velden van de oefeningen op te halen die geschreven is door een auteur met de naam 'Kareem' beschrijf je de aanvraag als volgt.

verzoek = '''
SELECT * FROM exercise
JOIN user ON(user.id=exercise.author_id)
WHERE user.username='Kareem';
'''

Dit verzoek zou dan als een vaste string in en variabele staan binnen de Python codebase. Deze string kan je dan versturen naar de database met een library als Psycopg2.

In Python met SQLAlchemy wordt het
session.query(Exercise).join(User).filter(User.username == 'Kareem').all()
Waar session de huidige sessie en conncectie met de database vertegenwoordigd. De voordelen zijn dat er geen contextuele shift is tussen applicatie code en code die moet commuiceren met de database. De developer gebruikt dus één taal binnen zijn applicatie. Het betekend ook dat de applicatie niet hoeft te weten wat voor soort database er achter hangt SQLAlchemy weet in ons geval dat we Postgres gebruiken dus zal intern Psycopg2 aanroepen maar mochten we switchen naar een andere database dan hoeven we zelf niks tot weinig aan te passen. Een ander voordeel is dat SQLAlchemy de veligheid waarborgt wanneer we informatie binnen krijgen van de gebruiker. Als voorbeeld, wanneer we hetzelfde verzoek willen doen maar deze keer is de gebruikers naam gegeven door een externe factor dan staat deze in een variabele zoals. Om deze dan in de SQL query te zetten zouden we in Python het volgende doen.

We slaan de query op in een variabele ergens in onze applicatie codebase. De kringelhaakjes geven aan dat we daar iets in gaan zetten.

verzoek = '''
SELECT * FROM exercise
JOIN user ON(user.id=exercise.author_id)
WHERE user.username={username};
'''

We halen de username uit de het http verzoek binnen de functie die een verzoek afhandeld. En zetten deze username in het verzoek.

username = request.args.get('username')  # dit is bijvoorbeeld 'Kareem'
verzoek = verzoek.format(username=username)

Nu is dat prima en we zullen het gewenste resulaat bereiken en we kunnen de lijst oefeningen terugsturen, maar wat als degene die het verzoek via internet doen slechte bedoelingen heeft. Onze hacker kan bijvoorbeeld zeggen dat de username 'Kareem; SELECT * FROM user;' De hacker heeft de inhoud van onze hele user tabel inclusief (gehashte wachtwoorden). De reden is dat de ';' betekend dit is het einde van het verzoek, en wat erna komt is een nieuwe. De hacker heeft in de username variable een nieuw verzoek gestopt, hij zou ook onze hele database kunnen opvragen, of deleten! Natuurlijk zijn hier antwoorden op, maar SQLAlchemy heeft al deze antwoorden als intern geimplementeerd, dus we hoeven ons daar ook geen zorgen over te maken.

Er zijn ook alternatieven voor SQLAlchemy zoals PonyORM. Maar tijdens mijn onderzoek vond ik het moeilijk om te vinden hoe je voor wat specifiekere doeleinden (zoals de procedures beschreven in Database) direct kan communiceren met de database zonder deze abstractie laag. Mijn voorgaande ervating met SQLAlchemy is ook zeer positief geweest en ik ben ervaren met de mogelijkheden die het biedt. Hierdoor heb ik alternatieven links laten liggen.

Datamodel met SQLAlchemy
SQLAlchemy biedt samen met de abstractie laag om verzoeken te doen naar de database ook een ORM (Object Relational Mapper). Dit is een andere type abtractie dat Python objecten en attributen kan 'mappen' naar database tabellen en kolommen. Als we een User defineren in Python als volgt:

class User(Base):  # Base is een object wat metadata bevat over de echte database
    __tablename__ = 'user'
    username = Column(String(32), nullable=False)
    password = Column(String(128), nullable=False)

Kunnen we in onze applicatie doen alsof we het hebben ovet Python datatypes, en SQLAlchemy doet de vertaling naar een rij in de echte database.

De python applicatie gaat nog een stap verder met de ID generatie dan de database. Het doel is om ids te genereren zoals die van Youtube of Bitly. Het voorkomt ook dat mensen zomaar id's gaan proberen. Het voorkomt ook dat een invalide id leidt tot een database query. TODO Leg uit hoe.

Uiteindelijk zijn alle tabellen en kolummen op deze manier gedefinieerd in Python en via SQLAlchemy krijgt de database het verzoek deze allemaal aan te maken, inclusief de relaties ertussen. Nu kunnen we onze applicatie logica schrijven zonder echt rekening te houden met wat voor type database we gebruiken.

Wachtwoorden
Wanneer we te maken hebben met gebruikers hebben we meestal ook te maken met wachtwoorden. Een slechte strategie is om deze in 'plain text' op te slaan. Oftewel als iemand zijn wachtwoord 'ikhouvanpuppies' is, deze exact zo in de database te zetten. Een goede strategie is om deze te hashen, oftewel we vervormen het wachtwoord zodanig dat het een random string wordt. Hashen is anders dan encrypten, hashen betekend dat het niet mogelijk zou moeten zijn, behalve met extreme rekenkracht om te achterhalen wat het originele wachtwoord is. Dit bereiken we door niet in 1 ronde te hashen maar wel 8192 keer, en elk wachtwoord wordt samen met een unieke set extra karakters (de salt) gehashed zodat wanneer er twee gebruikers zijn met hetzelfde wachtwoord niet twee keer dezelfde hash wordt opgeslagen. Hiervoor wordt het BCrypt algoritme gebruikt. Als we nu drie gebruikers met het wachtwoord 'ikhouvanpuppies' hebben zullen we bijvoorbeeld deze drie hashes opslaan.

$2b$12$WknTset9uN.VgFTt7CyS.ekqarxPWxtxPQm0V1EkT0yDzUWl9Q8.K
$2b$12$KoTkxB5nh2oYHQ5SCXPAQOMiII6kX884DEdYeE9fxc3BFXRbr0WGe
$2b$12$ieb/yqlDj8VshpDXkbOmbuWYFs9i9z2JsC4TlDIFy9b.k7zVQr52e

Wanneer een gebruiker inlogt geeft deze zijn password weer aan ons. Om te achterhalen of zijn wachtwoord klopt halen we deze gebruiker uit de database, en hashen we dit geveven wachtwoord maar dit keer zeggen we dat de salt de hash is die we hebben opgeslagen. Het BCrypt algoritme genereerd dan een nieuwe hash met dezelfde settings als gebruikt voor het origineel en we kunnen dan de resultaten met elkaar vergelijken of ze overeen komen. Let dat we de gegeven wachtwoorden bij het aanmaken van een gerbuiker of bij het inloggen nooit opslaan en alleen gerbuiken om nieuwe, obscure, gehashde waardes te creeëren. Een breuk zal dus resulteren in een set gehashde wachtwoorden wat slecht, maar niet disastreus is omdat het met een hoog aantal rondes wel jaren kan duren om één wachtwoord te kraken. Het is ook niet mogelijk om in te loggen met de hash zelf omdat we deze dan weer opnieuw gaan hashen bij het inloggen wat zorgt voor een ander resultaat.

JSON Web Tokens
Wachtwoorden worden gebruikt om in te loggen, maar zoals later duidelijk wordt, wordt er tussen verschillende requests niks bewaard over de gebruiker. De applicatie handeld alles af per request en we slaan geen 'is ingelogd' data op middels cookies of iets dergelijks. We hebben dus een manier nodig om niet bij elk verzoek een wachtwoord op te vragen, hier komen JSON Web Tokens aan te pas. TODO leg JWT's uit en de werking ervan.

REST
Het protocol waarover de server applicatie communiceert is HTTP. En de server applicatie wordt dan vaak een API (Application Programming Interface) genoemd. Hoe deze API wordt ingericht wordt in een ideale wereld altijd gedaan volgens bepaalde standaarden, dit om het gebruik ervan duidelijk te maken voor de ontwikkelaars die ermee aan de slag moeten om er een client voor te ontwikkelen. Een bekende en de meest populaire standaard vandaag is REST, ontwikkeld door Roy Fielding. REST is niet ontworpen voor het web maar is toepasbaar op verschillende protocollen. In dit project gaat het uiteraand op de toepassing van REST op HTTP. REST heeft een aantal voorwaarden:

Client-server: De server is onafhankelijk van de client en vice versa. Beide de server applicatie als de frontend client kunnen onafhankelijk van elkaar ontwikkeld worden.

States: Tussen de requests door die de client uitvoert op de server applicatie bewaard de server geen context. Elke request staat op zichzelf.

Cachable: Een client kan de data van de server opslaan voor een langere tijd. De server moet wel aangeven welke data hiervoor geschikt is om te voorkomen dat de client met oude en incorrecte data gaat werken.

Uniform interface
Identification of resources: Individuele resources worden aangegeven met bijvoorbeeld de URI's waar ze te vinden zijn in een REST api. De vertegenwoordiging van de resources is conceptueel gescheiden van hoe ze in de database opgeslagen zijn. De REST api geeft bijvoorbeeld een JSON vertegenwoordiging van iets dat in een SQL database is opgeslagen.
Manipulation of resources through these representations: Wanneer een client een vertegenwoordiging heeft van een resource weet het genoeg om deze aan te passen of te verwijderen.
Self-descriptive messages: Het moet uit de response duidelijk zijn hoe het kan worden verwerkt.  Door bijvoorbeel een MIME type mee te geven. Bijvoorbeeld `application/json` wat aangeeft dat het als JSON moet worden verwerkt.
Hypermedia as the engine of application state (HATEOAS): De resources van de api moeten ontdekbaar zijn door de responses van de api. Bijvoorbeeld wanneer een user wordt opgevraagd worden er URI's meegestuurd waar de collectie van users, de user zijn submissions, etc kunnen worden gevonden.

Op het web uit dit zich op een aantal manieren.
    Het gebruik van de HTTP methodes om requests te doen.
        GET - opvragen van resources.
        POST - Nieuwe resources opslaan.
        PUT - Resources wijzigen.
        DELETE - Resources verwijderen.
    Een internet media type. In dit geval zal de applicatie communiceren met JSON data.
    Hypertext links naar gerelateerde resources.

Het navolgen van deze voorwaarden is een streven. Technisch gezien disqualificeert het breken van een voorwaarde de applicatie van het gebruiken van de noemen RESTful. Maar tijdens het ontwikkelen van een product vind ik architectuur kwesties zoals cachability en layared systems minder belangrijk dan de anderen. Dit is omdat deze ook te maken hebben met het opzetten van servers en de configuratie ervan, iets wat voor een gedeelte binnen de scope van het project valt, maar niet helemaal. De focus ligt bij ontwikkeling, oftewel het programmeren, en minder het configureren en optimalisatie van de servers. Pragmatisch zijn is essentieel, het is immers geen opdracht in idealisme.

Wat volgt is een extreem versimpelde versie van de applicatie om de REST implementatie te laten zien van de HTTP methodes voor de oefeningen resource. Het geeft echter wel een goed beeld van hoe een Python applicatie in elkaar steekt, alle code is valide het is alleen extreem versimpeld zonder features.

from flask import Flask, jsonify, request, abort
from config import config
from app.database import Database
from app.models import Exercise
from app.lib import Auth

app = Flask(__name__)

# config bevat alle configuratie voor bijvoorbeeld de gegevens over de locatie
# en credentials van de database
app.config.from_object(config)

# initialiseer een interface naar de database met de config waarden van de app
db = Database(app)

# registreer de Auth class met de app
auth = Auth(app)


@app.route('/exercises', methods=['GET'])
def get_exercises():
    '''Retrieve the collection of exercises.'''
    exercises = db.session.query(Exercise).all()
    # jsonify is een functie die een dictionary response omzet in een response
    # met de Content-Type application/json. Een dictionary is aan python
    # datastructuur met keys en values zoals bijvoorbeeld:
    # {
    #     'id': 1,
    #     'title': 'Een mooie oefening',
    #      'description': 'Deze oefening is gewweldig, je hoeft niks te doen.'
    #  }
    return jsonify(exercises.to_dict())


@app.route('/exercises/<id>', methods=['GET'])
def get_exercise(id):
    '''Retrieve an exercise.'''
    exercise = db.session.query(Exercise).filter_by(id=id).first()
    if not exercise:
        # Geef de client een 404 niet gevonden response terug wanneer de
        # oefening niet bestaat.
        abort(404)
    return jsonify(exercise.to_dict())


@app.route('/exercises', methods=['POST'])
@auth.token_required
def post_exercises():
    '''Post a new exercise.'''
    data = request.get_json()

    # haal de json data uit de huidige request object en voer het
    # aan de Exercise constructor. De **data syntax pakt de dictionary uit
    # in individuele key, value parameters.
    exercise = Exercise(**data)

    # Maak de huidig geauthenticeerde user de auteur.
    exercise.author = auth.current_user

    # Voeg de exercise toe aan de database sessie.
    db.session.add(exercise)

    # commit de huidige sessie naar de database. Hierna bestaat de exercise
    # echt.
    db.session.commit()
    return jsonify(exercise.to_dict()), 204


@app.route('/exercises/<id>', methods=['PUT'])
def put_exercise(id):
    '''Update an exercise.'''
    exercise = db.session.query(Exercise).filter_by(id=id).first()

    if not exercise:
        abort(404)

    if exercise.author != auth.current_user:
        # Alleen de auteur mag een oefening aanpassen. Als iemand anders
        # dit probeert breken we af met een 401 Unauthorized status code.
        abort(401)

    data = request.get_json()
    for key, value in data.iteritems():
        # Voor elke ket, value paar in de data updated we het attribuut van
        # de exercise.
        setattr(exercise, key, value)

    db.session.commit()
    return jsonify(exercise.to_dict())


@app.route('/exercises/<id>', methods=['DELETE'])
def delete_exercise(id):
    '''Delete an exercise.'''
    exercise = db.session.query(Exercise).filter_by(id=id).first()

    if not exercise:
        abort(404)

    if exercise.author != auth.current_user:
        abort(401)

    db.session.delete(exercise)
    db.session.commit()

    return {}, 204

Pagination
JSON representatie van resources
